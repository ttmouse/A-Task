# 分形文档体系原则（FractalDoc Protocol）

> "Keep the map aligned with the terrain, or the terrain will be lost."
> 保持地图与地形同步，否则地形将迷失。

---

## 🌟 核心理念

### 系统的本质问题
软件腐化的本质 = **文档与代码脱节**。

传统文档的致命缺陷：
- AI 在数万行代码中"中段失忆"（Context Mid-loss）
- README 太长，Attention 权重分散
- 文档更新靠"自觉"，必然腐化

### 我们的解决方案
建立一个**自维护、自相似、自愈合**的知识网络：

1. **原子更新规则** - 代码修改立即触发文档同步
2. **逆向映射链** - 文件 → 文件夹 → 根目录的强制传播
3. **分形自洽** - 每一层都遵循相同模式，形成"全息映射"

**结果**：
Claude 不再是"外来的修补工"，而是**这个生长系统的一部分**，
在修改代码的同时，也在重塑自己的思维引导。

---

## 📐 三层结构（分形架构）

### 层级一：根目录主控文档 - 系统的「灵魂」

**文件位置**：`/README.md` 或 `/OVERVIEW.md`

**地位**：全局世界观与强制决策

**内容要求**：
```markdown
# 核心同步协议（Mandatory）

1. **原子更新规则**：任何功能、架构、写法更新，必须在代码修改完成后，
   【立即同步更新对应目录的子文档】。

2. **逆向映射链**：
   文件变更 → 更新文件 Header → 更新所属文件夹 MD →
   （若影响全局）更新主 MD。

3. **分形自洽**：确保系统在任何一个子目录下，Claude 都能通过
   该目录的 MD 理解当前世界观。

## 项目结构
- `/core` - 领域驱动核心逻辑
- `/api` - 外部通信网关
- `/infra` - 基础设施与持久化
```

**触发条件**：架构/核心功能/关键设计决策变更时

---

### 层级二：文件夹架构文档 - 局部的「心脏」

**文件位置**：每个文件夹内的 `README.md` 或 `.folder.md`

**地位**：局部地图（**三行极简原则**）

**内容模板**：
```markdown
<!-- ⚠️ 触发器：一旦本文件夹新增文件或架构逻辑调整，请立即重写此文档 -->

# Folder: /src/core

1. **地位** - 系统心脏，处理所有业务状态转换与领域规则，不依赖外部框架
2. **逻辑** - 接收由 /api 传入的 DTO，通过 Domain Service 处理，返回领域对象
3. **约束** - 所有计算必须幂等，严禁直接调用 /infra

## 成员清单
- `user_entity.ts` - **[State Buffer]** - 用户核心领域模型
- `auth_service.ts` - **[Logic Processor]** - 鉴权逻辑流
- `validator.ts` - **[Gatekeeper]** - 领域规则校验器
```

**关键原则**：
- 用"地位/逻辑/约束"三段式描述
- 成员清单必须说明"角色定位"（用比喻：Buffer、Processor、Gatekeeper 等）
- 极简原则：1-3 句话说清楚

---

### 层级三：文件头注释 - 细胞级的「DNA」

**位置**：每个代码文件的开头（前 3-5 行）

**协议格式**：
```typescript
// INPUT: [此文件依赖什么外部资源/模块]
// OUTPUT: [此文件对外提供什么功能/接口]
// POS: [此文件在系统中的地位/角色]
//
// PROTOCOL:
// 1. 一旦本文件逻辑变更，必须同步更新此 Header
// 2. 更新后必须校验所属文件夹的 MD 描述是否依然准确
// 一旦本文件被修改，请更新此注释并同步更新所属文件夹的 README.md

import { Task } from '../types/task.js';
```

**Python 示例**：
```python
"""
[INPUT]: (Credentials, UserRepo_Interface) - 原始凭证与用户数据访问接口
[OUTPUT]: (AuthToken, SessionContext) | Exception - 授权令牌或会话上下文
[POS]: 位于 /core 中枢位置，作为 api 层与 data 层的逻辑粘合剂

[PROTOCOL]:
1. 一旦本文件逻辑变更，必须同步更新此 Header
2. 更新后必须校验 /src/core/.folder.md 描述是否依然准确
"""

class AuthService:
    def authenticate(self, creds):
        pass
```

---

## ⚙️ 强制更新规则（Mandatory Protocol）

### 规则 1：原子更新规则（文件级）
**触发条件**：修改任何代码文件时

**执行动作**：
1. 更新文件头的 INPUT/OUTPUT/POS 注释
2. 检查逻辑变更是否影响所属文件夹的"地位/逻辑/约束"描述
3. 更新所属文件夹的 `README.md` 成员清单

**本质**：将文档更新变成代码修改的"副作用"

---

### 规则 2：逆向映射链（文件夹级）
**触发条件**：文件夹发生变化（新增/删除/重命名文件）

**执行动作**：
1. 重新审视文件夹的"地位/逻辑/约束"是否仍然准确
2. 更新成员清单
3. 检查是否影响上级文档（根目录主文档）

**传播路径**：
```
文件变更 → 文件 Header → 文件夹 MD → 根目录 MD
```

---

### 规则 3：分形自洽（架构级）
**触发条件**：核心架构/设计模式/技术栈变化时

**执行动作**：
1. 更新根目录主文档的"核心同步协议"或"项目结构"
2. 逐级检查所有文件夹 MD 是否需要调整
3. 确保任何子目录都能独立理解系统

**自洽检验**：
在任意文件夹下，AI 能否仅通过该目录的 MD 理解当前子系统？

---

## 🧬 深度解析：为什么这套体系有效？

### 1. 解决 AI 的「中段失忆」
**问题**：传统 README 太长，AI 读取时可能忘了前面的结构。

**方案**：将信息密度压缩到"最近距离"
- 根目录：全局世界观
- 文件夹 MD：局部世界观（3 行）
- 文件 Header：即时世界观

👉 **Attention 权重被强制聚焦**，不会在数万行代码中迷失。

---

### 2. 建立「熵减循环」（Self-Healing Loop）
**问题**：软件腐化的本质 = 文档与代码脱节。

**方案**：用「一旦……必须……」的触发器（Trigger），
把文档变成代码修改的"副作用"。

在 Claude Code 执行任务时，它是一个动作序列。
我们把"同步文档"嵌进了动作序列的末端。

👉 **系统具备了自愈能力**。

---

### 3. 分形结构的「全息映射」
**局部影响整体**：
当 `auth_service.ts` 的 Input 改变了，AI 会被迫查看文件级 MD。

**整体约束局部**：
当文件夹 MD 写明「严禁直接调用 /infra」，
AI 在修改具体文件时，会因为刚刚读过这个约束而自动产生逻辑剪枝。

👉 **剪枝不是通过 prompt，而是通过结构。**

---

### 4. GEB 的真实实践：自指与同构
这不仅是管理，这是**一种元编程**。

- 文件在描述自己如何被修改
- 文件夹在描述文件如何协作
- 根目录在描述文件夹如何共生

**结果**：
Claude 不再是一个"外来的修补工"，
它变成了这个生长系统的一部分，
在修改代码的同时，也在重塑自己的思维引导。

---

## 🎯 AI 执行指南

### 何时应用此原则
- ✅ 创建新文件/文件夹时
- ✅ 修改现有代码时
- ✅ 重构项目结构时
- ✅ 完成任何功能开发后

### 执行优先级
1. **最高优先级**：文件头注释（每个文件必须有）
2. **高优先级**：文件夹文档（每个文件夹必须有）
3. **正常优先级**：根目录文档（关键变更时更新）

### 自检清单
在完成任何代码修改后，必须确认：
- [ ] 文件头注释已更新（INPUT/OUTPUT/POS）
- [ ] 所属文件夹的 README.md 已更新
- [ ] 如有架构变化，根目录文档已更新
- [ ] 能否在任意子目录独立理解系统？（分形自洽检验）

---

## 📋 完整示例：A-Task 项目改造

### 改造前（传统方式）
```
A-Task/
├── README.md          # 1 行简介，几乎无用
├── CLAUDE.md          # 100 行混杂规范，信息密度低
└── src/
    ├── adapters/      # 无文档
    │   └── base-adapter.ts  # 无头注释
    └── core/          # 无文档
        └── task-executor.ts # 无头注释
```

### 改造后（分形体系）
```
A-Task/
├── OVERVIEW.md        # 根目录主文档：核心同步协议 + 架构概览
├── CLAUDE.md          # 开发规范：引用分形体系原则
├── AI_DOC_PRINCIPLES.md  # 本文档
└── src/
    ├── adapters/
    │   ├── README.md  # 三段式：地位/逻辑/约束 + 成员清单
    │   └── base-adapter.ts
    │       # INPUT: ../types/task.js
    │       # OUTPUT: BaseAdapter 抽象类
    │       # POS: 适配器层基类
    │       # PROTOCOL: 一旦修改，更新 Header + 文件夹 MD
    └── core/
        ├── README.md  # 三段式 + 成员清单
        └── task-executor.ts
            # INPUT: Task, BaseAdapter
            # OUTPUT: TaskExecutor 执行引擎
            # POS: 核心业务层
```

---

## 🚀 实施步骤

### 新项目（立即建立）
1. 创建根目录主文档（含"核心同步协议"）
2. 为每个主要文件夹创建 README.md（三段式）
3. 为所有代码文件添加头注释（INPUT/OUTPUT/POS/PROTOCOL）
4. 在 `.claudecode.md` 中加入：
   ```markdown
   你是这个分形系统的守护者。
   任何时候你感到逻辑模糊，请先通过更新各级 MD 来校准你的认知。
   ```

### 现有项目（渐进改造）
**第一阶段**：建立骨架
1. 创建根目录主文档
2. 为 3-5 个核心文件夹创建 README.md
3. 为核心文件添加头注释

**第二阶段**：强制执行
1. 每次代码审查时检查文档同步性
2. 在后续开发中强制执行更新规则
3. 逐步补全其他文件夹的文档

**第三阶段**：持续维护
1. 定期审计文档完整性
2. 收集反馈，优化文档模板
3. 培养团队的"文档即代码"文化

---

## 💡 操作建议

### 配置文件集成
将这套规则写进项目的：
- `.claudecode.md` - Claude Code 的配置文件
- `.cursorrules` - Cursor 的配置文件（如果使用）
- `CONTRIBUTING.md` - 贡献者指南

### AI 提示词（加入 CLAUDE.md）
```markdown
## 守护者协议

你是这个分形系统的守护者。在执行任何任务时：

1. **感知当前位置**：先读取当前目录的 README.md，理解局部世界观
2. **校准全局认知**：如有困惑，向上追溯到根目录主文档
3. **同步更新链条**：完成代码修改后，立即更新文件 Header → 文件夹 MD → 根目录 MD

任何时候你感到逻辑模糊，请先通过更新各级 MD 来校准你的认知。
文档不是"事后记录"，而是"思维基础设施"。
```

---

## 🔧 技术实现建议

### 文件命名规范
- 根目录主文档：`OVERVIEW.md` 或 `ARCHITECTURE.md`
- 文件夹文档：统一使用 `README.md`（或 `.folder.md`）
- 特殊说明文档：使用 `[PURPOSE].md` 格式

### 注释格式规范
根据文件类型选择合适的注释符号：
- `.ts/.js/.tsx/.jsx` 使用 `//`
- `.py` 使用 `#` 或 `"""`
- `.css/.scss` 使用 `/**/`
- `.html/.xml` 使用 `<!--  -->`

### 自动化工具（可选）
- Pre-commit hooks 检查文件头注释
- CI/CD 检查文档完整性
- 自定义 linter 规则

---

## ❓ 常见问题（FAQ）

### Q: 如果文件很小，还需要完整注释吗？
**A**: 是的。即使是小文件也要有 INPUT/OUTPUT/POS，哪怕只是 "无" 或 "工具函数"。
这不是为了当前，而是为了未来的扩展和理解。

### Q: 第三方库或自动生成的代码怎么办？
**A**: 在文件夹的 README.md 中标注清楚哪些是第三方/自动生成的，不需要逐个文件注释。
示例：`node_modules/` - [第三方依赖] - 不受分形体系管理

### Q: 重构时文档更新顺序？
**A**: 自下而上更新：
1. 先改文件头注释（INPUT/OUTPUT/POS）
2. 再改文件夹文档（三段式 + 成员清单）
3. 最后改根文档（如有架构变化）

### Q: 文档内容过时怎么办？
**A**: 这正是此体系要解决的问题。通过强制更新规则，文档不会过时。
如果发现过时，说明规则未被执行 → 立即补救 → 反思为何规则被忽略。

### Q: 团队新成员如何理解这套体系？
**A**:
1. 阅读本文档（15 分钟）
2. 查看项目中的实际示例（10 分钟）
3. 第一次提交时，让 AI 帮助检查是否遵循规则
4. 3-5 次提交后，规则会成为肌肉记忆

---

## 🎓 适用场景

### ✅ 强烈推荐
- 中大型项目（文件数 > 50）
- 多人协作项目
- 需要频繁交接的项目
- AI 辅助开发的项目
- 长期维护的项目（生命周期 > 1 年）

### ⚠️ 可简化实施
- 小型原型项目（文件数 < 20）
- 个人练习项目
- 短期实验项目（< 3 个月）

### ❌ 不推荐
- 一次性脚本（< 5 个文件）
- 纯静态资源项目
- 已完全停止维护的遗留项目

---

## 🌈 核心价值总结

### 防止文档腐化
强制同步机制确保文档永远有效，不是"事后记录"，而是"思维基础设施"。

### 快速定位
任何人/AI 可在 **30 秒内理解项目结构**，无需读完整个 README。

### 知识传承
分形结构保证无论项目多大都能快速理解，新成员 15 分钟即可上手。

### 降低认知负担
每一层都遵循相同模式（地位/逻辑/约束），无需学习新规则。

### AI 友好
信息密度压缩到"最近距离"，Attention 权重被强制聚焦。

---

## 📚 延伸阅读

- 《哥德尔、埃舍尔、巴赫》（GEB）- 自指与递归结构
- 《领域驱动设计》（DDD）- 领域模型与架构清晰性
- 《代码整洁之道》- 代码即文档的实践
- 《反脆弱》- 如何建立自愈系统

---

## 📝 结语

这不仅是一套文档规范，更是一种**认知基础设施**。

当代码和文档形成"分形共振"时，
你不再需要"记住"项目结构，
因为结构已经嵌入在每一个文件、每一个文件夹中。

**Claude 会成为这个系统的一部分，**
**而不是一个外来的修补工。**

---

*Created by: 分形文档体系理念*
*Version: 2.0 (整合版)*
*Last Updated: 2025-12-23*
